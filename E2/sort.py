# Del analisis hecho en la parte de abajo, pude generalizar una complejidad en el peor caso de:
# Comparaciones: n^2 + 2n - 2   : O(n^2)
# Asignaciones:  n^2 + 3n - 2   : O(n^2)
# Instancias:    0
# Alojamiento:   0
def insertSort(A):
    # -----------------------------------------------------------------------------------------------------
    comp = 0
    asig = 0
    # -----------------------------------------------------------------------------------------------------

    n = len(A) # Size del Vector
    i = 1
    # -----------------------------------------------------------------------------------------------------
    asig = asig + 2 # n = len(A) (linea 59) +
                    # La primera asignacion del i de arriba (linea 60)
    # -----------------------------------------------------------------------------------------------------
    while i < n:
        # -------------------------------------------------------------------------------------------------
        comp = comp + 1 # Comparacion del while (linea 65)
        # -------------------------------------------------------------------------------------------------
        key = A[i]
        j = i - 1
        # -------------------------------------------------------------------------------------------------
        asig = asig + 2 # key = A[i] (linea 69) +
                        # j = i - 1 (linea 70)
        # -------------------------------------------------------------------------------------------------
        while j >= 0 and A[j] > key:
            # ---------------------------------------------------------------------------------------------
            comp = comp + 2 # Las 2 comparaciones del while (j >= 0 and A[j] > key) (linea 75)
            # ---------------------------------------------------------------------------------------------
            A[j + 1] = A[j]
            j = j - 1
            # ---------------------------------------------------------------------------------------------
            asig = asig + 2 # A[j + 1] = A[j] (linea 79) +
                            # El decremento del j (linea 80)
            # ---------------------------------------------------------------------------------------------
        # -------------------------------------------------------------------------------------------------
        comp = comp + 2 # Comparaciones 'extra' del while al no cumplir con la condicion (linea 75)
        # -------------------------------------------------------------------------------------------------
        A[j + 1] = key
        i = i + 1
        # ---------------------------------------------------------------------------------------------
        asig = asig + 2 # A[j + 1] = key (linea 88) +
                        # El incremento del i (linea 89)
        # ---------------------------------------------------------------------------------------------
    # -------------------------------------------------------------------------------------------------
    comp = comp + 1 # Comparacion 'extra' del while al no cumplir con la condicion (linea 65)
    # -------------------------------------------------------------------------------------------------

    return (comp, asig, 0, 0) # Retornado como 4-tupla

# Intercalacion
def merge(A, p, q, r):
    B = [0] * len(A)
    for i in range(p, q + 1):
        B[i] = A[i]
    for j in range(q + 1, r + 1):
        B[q + (r - j + 1)] = A[j]
    i = p
    j = r
    for k in range(p, r + 1):
        if B[i] <= B[j]:
            A[k] = B[i]
            i = i + 1
        else:
            A[k] = B[j]
            j = j - 1

# Complejidad: 6n + 5
def mergeSort(A, p, r):
    if p < r:
        q = (p + r) // 2
        mergeSort(A, p, q)
        mergeSort(A, q + 1, r)
        merge(A, p, q, r)
