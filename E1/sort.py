# Del analisis hecho en la parte de abajo, pude generalizar una complejidad en el peor caso de:
# Comparaciones: n^2 + 2    : O(n^2)
# Asignaciones:  4n^2 + 4   : O(n^2)
# Instancias:    n + 1      : O(n)
# Alojamiento:   0          : O(1)
def bubbleSort(A):
    # -----------------------------------------------------------------------------------------------------
    comp = 0
    asig = 0
    objc = 0
    # -----------------------------------------------------------------------------------------------------

    n = len(A) # Size del Vector
    # -----------------------------------------------------------------------------------------------------
    asig = asig + 2 # n = len(A) (linea 13) +
                    # La primera asignacion del i en el for de abajo (linea 19)
    objc = objc + 1 # Creacion de objeto range como objeto iterativo (linea 19)
    # -----------------------------------------------------------------------------------------------------
    for i in range(n):
        # -------------------------------------------------------------------------------------------------
        comp = comp + 1 # Comparacion del for para evaluar si esta en el rango (linea 19)
        asig = asig + 1 # Primera asignacion del j en el for de abajo (linea 25)
        objc = objc + 1 # Alojamiento de memoria del range como objeto iterativo (linea 25)
        # -------------------------------------------------------------------------------------------------
        for j in range(n - i - 1):
            # ---------------------------------------------------------------------------------------------
            comp = comp + 1 # Comparacion del for para evaluar si esta en el rango (linea 25)
            # ---------------------------------------------------------------------------------------------
            if A[j] > A[j + 1]:
                A[j], A[j + 1] = A[j + 1], A[j] # Swap abreviado
                # -----------------------------------------------------------------------------------------
                asig = asig + 3 # Un swap realiza 3 asignaciones (linea 30)
                # -----------------------------------------------------------------------------------------
            # ---------------------------------------------------------------------------------------------
            comp = comp + 1 # El if de arriba realiza una comparacion (linea 29)
            asig = asig + 1 # El aumento iterativo del for (j) (ref. linea 25)
            # ---------------------------------------------------------------------------------------------
        # -------------------------------------------------------------------------------------------------
        comp = comp + 1 # Comparacion 'extra' del for al ver que el iterador se salio del range (linea 25)
        asig = asig + 1 # El aumento iterativo del for (i) (ref. linea 19)
        # -------------------------------------------------------------------------------------------------
    # -----------------------------------------------------------------------------------------------------
    comp = comp + 1 # Comparacion 'extra' del for al ver que el iterador se salio del range (linea 19)
    # -----------------------------------------------------------------------------------------------------

    return (comp, asig, objc, 0) # Retornado como 4-tupla

# Del analisis hecho en la parte de abajo, pude generalizar una complejidad en el peor caso de:
# Comparaciones: n^2 + 2n - 2   : O(n^2)
# Asignaciones:  n^2 + 3n - 2   : O(n^2)
# Instancias:    0
# Alojamiento:   0
def insertSort(A):
    # -----------------------------------------------------------------------------------------------------
    comp = 0
    asig = 0
    # -----------------------------------------------------------------------------------------------------

    n = len(A) # Size del Vector
    i = 1
    # -----------------------------------------------------------------------------------------------------
    asig = asig + 2 # n = len(A) (linea 59) +
                    # La primera asignacion del i de arriba (linea 60)
    # -----------------------------------------------------------------------------------------------------
    while i < n:
        # -------------------------------------------------------------------------------------------------
        comp = comp + 1 # Comparacion del while (linea 65)
        # -------------------------------------------------------------------------------------------------
        key = A[i]
        j = i - 1
        # -------------------------------------------------------------------------------------------------
        asig = asig + 2 # key = A[i] (linea 69) +
                        # j = i - 1 (linea 70)
        # -------------------------------------------------------------------------------------------------
        while j >= 0 and A[j] > key:
            # ---------------------------------------------------------------------------------------------
            comp = comp + 2 # Las 2 comparaciones del while (j >= 0 and A[j] > key) (linea 75)
            # ---------------------------------------------------------------------------------------------
            A[j + 1] = A[j]
            j = j - 1
            # ---------------------------------------------------------------------------------------------
            asig = asig + 2 # A[j + 1] = A[j] (linea 79) +
                            # El decremento del j (linea 80)
            # ---------------------------------------------------------------------------------------------
        # -------------------------------------------------------------------------------------------------
        comp = comp + 2 # Comparaciones 'extra' del while al no cumplir con la condicion (linea 75)
        # -------------------------------------------------------------------------------------------------
        A[j + 1] = key
        i = i + 1
        # ---------------------------------------------------------------------------------------------
        asig = asig + 2 # A[j + 1] = key (linea 88) +
                        # El incremento del i (linea 89)
        # ---------------------------------------------------------------------------------------------
    # -------------------------------------------------------------------------------------------------
    comp = comp + 1 # Comparacion 'extra' del while al no cumplir con la condicion (linea 65)
    # -------------------------------------------------------------------------------------------------

    return (comp, asig, 0, 0) # Retornado como 4-tupla
